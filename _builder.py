import pathlib

SQ = chr(39)
BS = chr(92)
NL = chr(10)
DQ = chr(34)

L = []

L.append("#!/usr/bin/env python3")
L.append(DQ*3)
L.append("deploy_fixes.py - Deploy fixed text2sql files to Linux server and verify.")
L.append("CRITICAL: Does NOT touch the existing vLLM process on GPUs 0-3.")
L.append(DQ*3)
L.append("")
L.append("import sys")
L.append("import time")
L.append("import paramiko")
L.append("")
L.append("HOST = " + DQ + "192.168.10.40" + DQ)
L.append("PORT = 22")
L.append("USER = " + DQ + "root" + DQ)
L.append("PASS = os.environ.get(" + DQ + "SSH_PASSWORD" + DQ + ", " + DQ + DQ + ")")
L.append("")
L.append("UPLOADS = [")
L.append("    (r" + DQ + "D:" + BS + "Dev" + BS + "Linux_LLM" + BS + "app" + BS + "text2sql_pipeline.py" + DQ + ", " + DQ + "/root/text2sql/text2sql_pipeline.py" + DQ + "),")
L.append("    (r" + DQ + "D:" + BS + "Dev" + BS + "Linux_LLM" + BS + "app" + BS + "app.py" + DQ + ",               " + DQ + "/root/text2sql/app.py" + DQ + "),")
L.append("    (r" + DQ + "D:" + BS + "Dev" + BS + "Linux_LLM" + BS + "app" + BS + "db_setup.py" + DQ + ",           " + DQ + "/root/text2sql/db_setup.py" + DQ + "),")
L.append("    (r" + DQ + "D:" + BS + "Dev" + BS + "Linux_LLM" + BS + "app" + BS + ".env" + DQ + ",                  " + DQ + "/root/text2sql/.env" + DQ + "),")
L.append("]")
L.append("")
L.append("")
L.append("def ssh_exec(client, cmd, timeout=60):")
L.append("    stdin, stdout, stderr = client.exec_command(cmd, timeout=timeout)")
L.append("    out = stdout.read().decode(" + DQ + "utf-8" + DQ + ", errors=" + DQ + "replace" + DQ + ").strip()")
L.append("    err = stderr.read().decode(" + DQ + "utf-8" + DQ + ", errors=" + DQ + "replace" + DQ + ").strip()")
L.append("    if err and not out:")
L.append("        return err")
L.append("    if err:")
L.append("        return out + " + DQ + BS + "n" + DQ + " + err")
L.append("    return out")
L.append("")
L.append("")
L.append("def banner(title):")
L.append("    print()")
L.append("    print(" + DQ + "=" + DQ + " * 64)")
L.append("    print(f" + DQ + "  {title}" + DQ + ")")
L.append("    print(" + DQ + "=" + DQ + " * 64)")
L.append("")
L.append("")
L.append("def upload_via_sftp(client, results):")
L.append("    banner(" + DQ + "STEP 1 - UPLOAD FIXED FILES VIA SFTP" + DQ + ")")
L.append("    sftp = client.open_sftp()")
L.append("    try:")
L.append("        sftp.stat(" + DQ + "/root/text2sql" + DQ + ")")
L.append("    except FileNotFoundError:")
L.append("        sftp.mkdir(" + DQ + "/root/text2sql" + DQ + ")")
L.append("        print(" + DQ + "[INFO] Created /root/text2sql/" + DQ + ")")
L.append("")
L.append("    for local_path, remote_path in UPLOADS:")
L.append("        try:")
L.append("            sftp.put(local_path, remote_path)")
L.append("            remote_stat = sftp.stat(remote_path)")
L.append("            fname = remote_path.split(" + DQ + "/" + DQ + ")[-1]")
L.append("            print(f" + DQ + "[OK] Uploaded {local_path}" + DQ + ")")
L.append("            print(f" + DQ + "     -> {remote_path}  ({remote_stat.st_size} bytes)" + DQ + ")")
L.append("            results.append((f" + DQ + "Upload {fname}" + DQ + ", " + DQ + "PASS" + DQ + ", f" + DQ + "{remote_stat.st_size} bytes" + DQ + "))")
L.append("        except Exception as e:")
L.append("            fname = remote_path.split(" + DQ + "/" + DQ + ")[-1]")
L.append("            print(f" + DQ + "[FAIL] Upload failed for {local_path}: {e}" + DQ + ")")
L.append("            results.append((f" + DQ + "Upload {fname}" + DQ + ", " + DQ + "FAIL" + DQ + ", str(e)))")
L.append("    sftp.close()")
L.append("")
L.append("")
L.append("def restart_service(client):")
L.append("    banner(" + DQ + "STEP 2 - RESTART GRADIO SERVICE (text2sql-ui)" + DQ + ")")
L.append("    print(" + DQ + "[INFO] Running: systemctl restart text2sql-ui" + DQ + ")")
L.append("    out = ssh_exec(client, " + DQ + "systemctl restart text2sql-ui" + DQ + ", timeout=30)")
L.append("    if out:")
L.append("        print(out)")
L.append("    print(" + DQ + "[INFO] Waiting 10 seconds for service to start..." + DQ + ")")
L.append("    time.sleep(10)")
L.append("    print(" + DQ + "[INFO] Running: systemctl status text2sql-ui" + DQ + ")")
L.append("    out = ssh_exec(client, " + DQ + "systemctl status text2sql-ui 2>&1 | head -10" + DQ + ")")
L.append("    print(out)")
L.append("")
L.append("")
L.append("def verify_all(client, results):")
L.append("    banner(" + DQ + "STEP 3 - FULL VERIFICATION" + DQ + ")")
L.append("")
L.append("    # Check 1")
L.append("    print(" + DQ + BS + "n--- Check 1: systemctl is-active text2sql-ui ---" + DQ + ")")
L.append("    out = ssh_exec(client, " + DQ + "systemctl is-active text2sql-ui" + DQ + ")")
L.append("    status = " + DQ + "PASS" + DQ + " if out.strip() == " + DQ + "active" + DQ + " else " + DQ + "FAIL" + DQ)
L.append("    print(f" + DQ + "  Result: {out!r}  -> {status}" + DQ + ")")
L.append("    results.append((" + DQ + "Service active" + DQ + ", status, out.strip()))")
L.append("")
L.append("    # Check 2")
L.append("    print(" + DQ + BS + "n--- Check 2: Gradio HTTP 200 on port 7860 ---" + DQ + ")")
L.append("    out = ssh_exec(client, " + DQ + "curl -s -o /dev/null -w " + SQ + "%{http_code}" + SQ + " http://localhost:7860" + DQ + ")")
L.append("    status = " + DQ + "PASS" + DQ + " if out.strip() == " + DQ + "200" + DQ + " else " + DQ + "FAIL" + DQ)
L.append("    print(f" + DQ + "  HTTP status code: {out!r}  -> {status}" + DQ + ")")
L.append("    results.append((" + DQ + "Gradio HTTP 200" + DQ + ", status, f" + DQ + "HTTP {out.strip()}" + DQ + "))")
L.append("")
L.append("    # Check 3")
L.append("    print(" + DQ + BS + "n--- Check 3: vLLM /v1/models endpoint ---" + DQ + ")")
L.append("    cmd_vllm = (")
L.append("        " + DQ + "curl -s http://localhost:8000/v1/models | " + DQ)
L.append("        " + DQ + "python3 -c " + SQ + "import sys,json; d=json.load(sys.stdin); print(d[" + BS + DQ + "data" + BS + DQ + "][0][" + BS + DQ + "id" + BS + DQ + "])" + SQ + DQ)
L.append("    )")
L.append("    out = ssh_exec(client, cmd_vllm)")
L.append("    if out and " + DQ + "error" + DQ + " not in out.lower() and " + DQ + "traceback" + DQ + " not in out.lower():")
L.append("        status = " + DQ + "PASS" + DQ)
L.append("    else:")
L.append("        status = " + DQ + "FAIL" + DQ)
L.append("    print(f" + DQ + "  Model name: {out!r}  -> {status}" + DQ + ")")
L.append("    results.append((" + DQ + "vLLM alive" + DQ + ", status, out.strip()))")
L.append("")
L.append("    # Check 4: End-to-end test")
L.append("    print(" + DQ + BS + "n--- Check 4: End-to-end ask_hr() test ---" + DQ + ")")
L.append("    e2e_py = (")
L.append("        " + DQ + "from text2sql_pipeline import ask_hr" + BS + "n" + DQ)
L.append("        " + DQ + "r = ask_hr(" + SQ + "move_item_master" + BS + "uc5d0" + BS + "uc11c " + BS + "uc131" + BS + "ubcc4(gender_nm)" + BS + "ubcc4 " + BS + "uc778" + BS + "uc6d0" + BS + "uc218" + BS + "ub97c " + BS + "uad6c" + BS + "ud574" + BS + "uc918" + SQ + ")" + BS + "n" + DQ)
L.append("        " + DQ + "print(" + SQ + "SQL:" + SQ + ", r[" + SQ + "sql" + SQ + "])" + BS + "n" + DQ)
L.append("        " + DQ + "print(" + SQ + "Error:" + SQ + ", r[" + SQ + "error" + SQ + "])" + BS + "n" + DQ)
L.append("        " + DQ + "print(" + SQ + "Rows:" + SQ + ", len(r[" + SQ + "result" + SQ + "]) if r[" + SQ + "result" + SQ + "] is not None else 0)" + BS + "n" + DQ)
L.append("        " + DQ + "if r[" + SQ + "result" + SQ + "] is not None and len(r[" + SQ + "result" + SQ + "]) > 0:" + BS + "n" + DQ)
L.append("        " + DQ + "    print(r[" + SQ + "result" + SQ + "].to_string(index=False))" + BS + "n" + DQ)
L.append("    )")
L.append("    sftp = client.open_sftp()")
L.append("    with sftp.file(" + DQ + "/tmp/_e2e_test.py" + DQ + ", " + DQ + "w" + DQ + ") as f:")
L.append("        f.write(e2e_py)")
L.append("    sftp.close()")
L.append("    e2e_cmd = " + DQ + "cd /root/text2sql && /root/miniconda3/envs/text2sql/bin/python /tmp/_e2e_test.py" + DQ)
L.append("    out = ssh_exec(client, e2e_cmd, timeout=120)")
L.append("    print(out)")
L.append("    has_sql = " + DQ + "SQL:" + DQ + " in out and len(out.split(" + DQ + "SQL:" + DQ + ")[1].strip()) > 0")
L.append("    has_rows = " + DQ + "Rows:" + DQ + " in out")
L.append("    error_line = " + DQ + DQ)
L.append("    for line in out.splitlines():")
L.append("        if line.startswith(" + DQ + "Error:" + DQ + "):")
L.append("            error_line = line.split(" + DQ + "Error:" + DQ + ")[1].strip()")
L.append("    no_error = error_line in (" + DQ + "None" + DQ + ", " + DQ + DQ + ")")
L.append("    if has_sql and has_rows and no_error:")
L.append("        status = " + DQ + "PASS" + DQ)
L.append("        detail = " + DQ + "Query returned results, no error" + DQ)
L.append("    else:")
L.append("        status = " + DQ + "FAIL" + DQ)
L.append("        detail = f" + DQ + "sql_ok={has_sql}, rows_ok={has_rows}, error={error_line!r}" + DQ)
L.append("    print(f" + DQ + "  -> {status}: {detail}" + DQ + ")")
L.append("    results.append((" + DQ + "E2E ask_hr()" + DQ + ", status, detail))")
L.append("")
L.append("    # Check 5: SQL safety guard")
L.append("    print(" + DQ + BS + "n--- Check 5: SQL safety guard (_is_safe_sql) ---" + DQ + ")")
L.append("    safety_py = (")
L.append("        " + DQ + "from text2sql_pipeline import _is_safe_sql" + BS + "n" + DQ)
L.append("        " + DQ + "tests = [" + BS + "n" + DQ)
L.append("        " + DQ + "    (" + SQ + "SELECT * FROM t" + SQ + ", True)," + BS + "n" + DQ)
L.append("        " + DQ + "    (" + SQ + "DELETE FROM t" + SQ + ", False)," + BS + "n" + DQ)
L.append("        " + DQ + "    (" + SQ + "SELECT * FROM (DELETE FROM t)" + SQ + ", False)," + BS + "n" + DQ)
L.append("        " + DQ + "    (" + SQ + "SELECT 1; DROP TABLE t" + SQ + ", False)," + BS + "n" + DQ)
L.append("        " + DQ + "    (" + SQ + "WITH x AS (SELECT 1) SELECT * FROM x" + SQ + ", True)," + BS + "n" + DQ)
L.append("        " + DQ + "]" + BS + "n" + DQ)
L.append("        " + DQ + "all_pass = True" + BS + "n" + DQ)
L.append("        " + DQ + "for sql, expected in tests:" + BS + "n" + DQ)
L.append("        " + DQ + "    result = _is_safe_sql(sql)" + BS + "n" + DQ)
L.append("        " + DQ + "    st = " + SQ + "PASS" + SQ + " if result == expected else " + SQ + "FAIL" + SQ + BS + "n" + DQ)
L.append("        " + DQ + "    if st == " + SQ + "FAIL" + SQ + ": all_pass = False" + BS + "n" + DQ)
L.append("        " + DQ + "    print(f" + SQ + "{st}: _is_safe_sql({sql!r}) = {result} (expected {expected})" + SQ + ")" + BS + "n" + DQ)
L.append("        " + DQ + "print(" + SQ + "ALL_PASS" + SQ + " if all_pass else " + SQ + "SOME_FAIL" + SQ + ")" + BS + "n" + DQ)
L.append("    )")
L.append("    sftp = client.open_sftp()")
L.append("    with sftp.file(" + DQ + "/tmp/_safety_test.py" + DQ + ", " + DQ + "w" + DQ + ") as f:")
L.append("        f.write(safety_py)")
L.append("    sftp.close()")
L.append("    safety_cmd = " + DQ + "cd /root/text2sql && /root/miniconda3/envs/text2sql/bin/python /tmp/_safety_test.py" + DQ)
L.append("    out = ssh_exec(client, safety_cmd, timeout=30)")
L.append("    print(out)")
L.append("    status = " + DQ + "PASS" + DQ + " if " + DQ + "ALL_PASS" + DQ + " in out else " + DQ + "FAIL" + DQ)
L.append("    fail_count = out.count(" + DQ + "FAIL:" + DQ + ")")
L.append("    pass_count = out.count(" + DQ + "PASS:" + DQ + ")")
L.append("    detail = f" + DQ + "{pass_count} passed, {fail_count} failed" + DQ)
L.append("    print(f" + DQ + "  -> {status}: {detail}" + DQ + ")")
L.append("    results.append((" + DQ + "SQL safety guard" + DQ + ", status, detail))")
L.append("")
L.append("    # Check 6")
L.append("    print(" + DQ + BS + "n--- Check 6: vllm.service is masked ---" + DQ + ")")
L.append("    out = ssh_exec(client, " + DQ + "systemctl is-enabled vllm 2>&1" + DQ + ")")
L.append("    status = " + DQ + "PASS" + DQ + " if out.strip() == " + DQ + "masked" + DQ + " else " + DQ + "FAIL" + DQ)
L.append("    print(f" + DQ + "  Result: {out!r}  -> {status}" + DQ + ")")
L.append("    results.append((" + DQ + "vllm masked" + DQ + ", status, out.strip()))")
L.append("")
L.append("")
L.append("def print_summary(results):")
L.append("    banner(" + DQ + "FINAL SUMMARY" + DQ + ")")
L.append("    h = " + DQ + "#" + DQ)
L.append("    ck = " + DQ + "Check" + DQ)
L.append("    st_h = " + DQ + "Status" + DQ)
L.append("    print(f" + DQ + "{h:<4} {ck:<30} {st_h:<8} Detail" + DQ + ")")
L.append("    print(" + DQ + "-" + DQ + " * 80)")
L.append("    all_ok = True")
L.append("    for i, (name, st, detail) in enumerate(results, 1):")
L.append("        print(f" + DQ + "{i:<4} {name:<30} {st:<8} {detail}" + DQ + ")")
L.append("        if st != " + DQ + "PASS" + DQ + ":")
L.append("            all_ok = False")
L.append("    print(" + DQ + "-" + DQ + " * 80)")
L.append("    if all_ok:")
L.append("        print(" + DQ + "ALL CHECKS PASSED - Deployment successful." + DQ + ")")
L.append("    else:")
L.append("        print(" + DQ + "SOME CHECKS FAILED - Review output above." + DQ + ")")
L.append("    print()")
L.append("    return all_ok")
L.append("")
L.append("")
L.append("def main():")
L.append("    results = []")
L.append("    banner(" + DQ + "CONNECTING TO SERVER" + DQ + ")")
L.append("    client = paramiko.SSHClient()")
L.append("    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())")
L.append("    try:")
L.append("        client.connect(HOST, port=PORT, username=USER, password=PASS, timeout=15)")
L.append("    except Exception as e:")
L.append("        print(f" + DQ + "[FATAL] SSH connection failed: {e}" + DQ + ")")
L.append("        sys.exit(1)")
L.append("    print(f" + DQ + "[OK] Connected to {USER}@{HOST}" + DQ + ")")
L.append("")
L.append("    upload_via_sftp(client, results)")
L.append("    restart_service(client)")
L.append("    verify_all(client, results)")
L.append("    all_ok = print_summary(results)")
L.append("")
L.append("    client.close()")
L.append("    return 0 if all_ok else 1")
L.append("")
L.append("")
L.append("if __name__ == " + DQ + "__main__" + DQ + ":")
L.append("    sys.exit(main())")

content = NL.join(L) + NL
pathlib.Path("D:/Dev/Linux_LLM/deploy_fixes.py").write_text(content, encoding="utf-8")
print(f"Wrote deploy_fixes.py: {len(content)} bytes, {len(L)} lines")
